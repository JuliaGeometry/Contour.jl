{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nContour.jl uses the \nmarching squares algorithm\n to find \nisolines\n of a discrete data set representing a function $z = f(x, y)$.", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Contour.jl uses the  marching squares algorithm  to find  isolines  of a discrete data set representing a function $z = f(x, y)$.", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\n\n\nTL;DR: If you read nothing else, read this\n\n\nThe most common use case for this package is plotting iso lines. Here's a complete example that lets you do that, while showing off all of the most important features of the package:\n\n\nfor cl in levels(contours(x,y,z))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot(xs, ys, color=lvl) # pseuod-code; use whatever plotting package you prefer\n    end\nend\n\n# output\n\n\n\n\n\n\n\nPreface: some test data...\n\n\nThe Contour module expects input data to be on a Cartesian grid, and supports both uniform and non-uniform grid spacings.  For the following examples, \nx\n and \ny\n are 1D sorted arrays that contain the grid coordinates, and \nz\n is a matrix arranged such that \nz[xi,yi]\n correspond to the location \n(x[xi], y[yi])\n.\n\n\nLet's consider the function $z(x,y) = x^2 + y^2$:\n\n\nx = -3:0.01:3\ny = -4:0.02:5\n\nz = [Float64((xi^2 + yi^2)) for xi in x, yi in y]\n\n\n\n\nx\n and \ny\n don't have to be evenly spaced - they can just as well be (sorted) arrays of coordinate values.\n\n\n\n\nExample: plotting isolines\n\n\nUsually, you'll start by calling \ncontours\n:\n\n\nc = contours(x,y,z)\n\n# output\nContour.ContourCollection{Contour.ContourLevel{Float64}}\n with 10 level(s).\n\n\n\n\nThe package is designed so that you shouldn't have to worry about the types of the outputs - instead, there are functions that let you extract the data you need. So, instead of simply returning a \nVector{ContourLevel}\n, we return a special object which supports the \nlevels\n function. \nlevels\n in turn returns a collection of \nContourLevel\ns which you can iterate over:\n\n\nfor cl in levels(c)\n    # do something\nend\n\n# output\n\n\n\n\n\nOn each level (\ncl\n in the snippet above) there are two pieces of information that can be of interest. You find the $z$-value of the isoline with the \nlevel\n function, while \nlines\n yields an iterable collection of line segments (remember that there might be more than one isoline for a given $z$-value):\n\n\nlevel(cl), length(lines(cl))\n\n# output\n(3.090909090909091,1)\n\n\n\n\nThis contour level only had one line. An isoline is represented as a sequence of vertices, which either starts and ends at the boundaries of the data set, or closes on itself, in which case the first and last points are equal.\n\n\nThe $x$- and $y$-coordinates of an isoline are extracted using the \ncoordinates\n function:\n\n\nl = first(lines(cl))\nxs, ys = coordinates(l)\n\ntypeof(xs)\n\n# output\nArray{Float64,1}\n\n\n\n\nNow we understand all the parts of the plotting example at the top:\n\n\nfor cl in levels(contours(x,y,z))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot(xs, ys, color=lvl) # pseuod-code; use whatever plotting package you prefer\n    end\nend\n\n# output\n\n\n\n\n\n\n\nAffecting the choice of contour levels\n\n\nThere are several ways to affect the choice of contour levels.\n\n\nFirst, you can specify them manually:\n\n\ncontours(x, y, z, [2,3])\n\n# output\nContour.ContourCollection{Contour.ContourLevel{Float64}}\n with 2 level(s).\n\n\n\n\nYou can also just specify the number of levels you want, and let the package choose them:\n\n\ncontours(x, y, z, 2)\n\n# output\nContour.ContourCollection{Contour.ContourLevel{Float64}}\n with 2 level(s).\n\n\n\n\nThe package uses \nContour.contourlevels\n to choose the levels, so it's entirely possible to investigate what levels would be traced without doing any plotting:\n\n\nContour.contourlevels(z, 4)\n\n# output\n6.8:6.8:27.2\n\n\n\n\nIf you only want a single contour level, use the \ncontour\n function directly - its fourth parameter is the $z$-value at which to trace the isolines:\n\n\ncontour(x, y, z, 2.3)\n\n# output\nContour.ContourLevel{Float64}\n  at 2.3 with 1 line(s)", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tldr-if-you-read-nothing-else-read-this", 
            "text": "The most common use case for this package is plotting iso lines. Here's a complete example that lets you do that, while showing off all of the most important features of the package:  for cl in levels(contours(x,y,z))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot(xs, ys, color=lvl) # pseuod-code; use whatever plotting package you prefer\n    end\nend\n\n# output", 
            "title": "TL;DR: If you read nothing else, read this"
        }, 
        {
            "location": "/tutorial/#preface-some-test-data", 
            "text": "The Contour module expects input data to be on a Cartesian grid, and supports both uniform and non-uniform grid spacings.  For the following examples,  x  and  y  are 1D sorted arrays that contain the grid coordinates, and  z  is a matrix arranged such that  z[xi,yi]  correspond to the location  (x[xi], y[yi]) .  Let's consider the function $z(x,y) = x^2 + y^2$:  x = -3:0.01:3\ny = -4:0.02:5\n\nz = [Float64((xi^2 + yi^2)) for xi in x, yi in y]  x  and  y  don't have to be evenly spaced - they can just as well be (sorted) arrays of coordinate values.", 
            "title": "Preface: some test data..."
        }, 
        {
            "location": "/tutorial/#example-plotting-isolines", 
            "text": "Usually, you'll start by calling  contours :  c = contours(x,y,z)\n\n# output\nContour.ContourCollection{Contour.ContourLevel{Float64}}\n with 10 level(s).  The package is designed so that you shouldn't have to worry about the types of the outputs - instead, there are functions that let you extract the data you need. So, instead of simply returning a  Vector{ContourLevel} , we return a special object which supports the  levels  function.  levels  in turn returns a collection of  ContourLevel s which you can iterate over:  for cl in levels(c)\n    # do something\nend\n\n# output  On each level ( cl  in the snippet above) there are two pieces of information that can be of interest. You find the $z$-value of the isoline with the  level  function, while  lines  yields an iterable collection of line segments (remember that there might be more than one isoline for a given $z$-value):  level(cl), length(lines(cl))\n\n# output\n(3.090909090909091,1)  This contour level only had one line. An isoline is represented as a sequence of vertices, which either starts and ends at the boundaries of the data set, or closes on itself, in which case the first and last points are equal.  The $x$- and $y$-coordinates of an isoline are extracted using the  coordinates  function:  l = first(lines(cl))\nxs, ys = coordinates(l)\n\ntypeof(xs)\n\n# output\nArray{Float64,1}  Now we understand all the parts of the plotting example at the top:  for cl in levels(contours(x,y,z))\n    lvl = level(cl) # the z-value of this contour level\n    for line in lines(cl)\n        xs, ys = coordinates(line) # coordinates of this line segment\n        plot(xs, ys, color=lvl) # pseuod-code; use whatever plotting package you prefer\n    end\nend\n\n# output", 
            "title": "Example: plotting isolines"
        }, 
        {
            "location": "/tutorial/#affecting-the-choice-of-contour-levels", 
            "text": "There are several ways to affect the choice of contour levels.  First, you can specify them manually:  contours(x, y, z, [2,3])\n\n# output\nContour.ContourCollection{Contour.ContourLevel{Float64}}\n with 2 level(s).  You can also just specify the number of levels you want, and let the package choose them:  contours(x, y, z, 2)\n\n# output\nContour.ContourCollection{Contour.ContourLevel{Float64}}\n with 2 level(s).  The package uses  Contour.contourlevels  to choose the levels, so it's entirely possible to investigate what levels would be traced without doing any plotting:  Contour.contourlevels(z, 4)\n\n# output\n6.8:6.8:27.2  If you only want a single contour level, use the  contour  function directly - its fourth parameter is the $z$-value at which to trace the isolines:  contour(x, y, z, 2.3)\n\n# output\nContour.ContourLevel{Float64}\n  at 2.3 with 1 line(s)", 
            "title": "Affecting the choice of contour levels"
        }, 
        {
            "location": "/reference/", 
            "text": "Entry points\n\n\n#\n\n\nContour.contour\n \n \nFunction\n.\n\n\ncontour(x, y, z, level::Number)\n Trace a single contour level, indicated by the argument \nlevel\n.\n\n\nYou'll usually call \nlines\n on the output of \ncontour\n, and then iterate over the result.\n\n\nsource\n\n\n#\n\n\nContour.contours\n \n \nFunction\n.\n\n\ncontours\n returns a set of isolines.\n\n\nYou'll usually call \nlevels\n on the output of \ncontours\n.\n\n\nsource\n\n\ncontours(x,y,z,levels)\n Trace the contour levels indicated by the \nlevels\n argument.\n\n\nsource\n\n\ncontours(x,y,z,Nlevels::Integer)\n Trace \nNlevels\n contour levels at heights chosen by the library (using the  \ncontourlevels\n function).\n\n\nsource\n\n\ncontours(x,y,z)\n Trace 10 automatically chosen contour levels.\n\n\nsource\n\n\n\n\nAccessors\n\n\n#\n\n\nContour.level\n \n \nFunction\n.\n\n\nlevel(c)\n Indicates the \nz\n-value at which the contour level \nc\n was traced.\n\n\nsource\n\n\n#\n\n\nContour.levels\n \n \nFunction\n.\n\n\nTurns the output of \ncontours\n into an iterable with each of the traced contour levels. Each of the objects support \nlevel\n and \ncoordinates\n.\n\n\nsource\n\n\n#\n\n\nContour.lines\n \n \nFunction\n.\n\n\nlines(c)\n Extracts an iterable collection of isolines from a contour level. Use \ncoordinates\n to get the coordinates of a line.\n\n\nsource\n\n\n#\n\n\nContour.coordinates\n \n \nFunction\n.\n\n\ncoordinates(c)\n Returns the coordinates of the vertices of the contour line as a tuple of lists.\n\n\nsource\n\n\n\n\nUtilities\n\n\n#\n\n\nContour.contourlevels\n \n \nFunction\n.\n\n\ncontourlevels(z,n)\n Examines the values of \nz\n and chooses \nn\n evenly spaced levels to trace.\n\n\nsource", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#entry-points", 
            "text": "#  Contour.contour     Function .  contour(x, y, z, level::Number)  Trace a single contour level, indicated by the argument  level .  You'll usually call  lines  on the output of  contour , and then iterate over the result.  source  #  Contour.contours     Function .  contours  returns a set of isolines.  You'll usually call  levels  on the output of  contours .  source  contours(x,y,z,levels)  Trace the contour levels indicated by the  levels  argument.  source  contours(x,y,z,Nlevels::Integer)  Trace  Nlevels  contour levels at heights chosen by the library (using the   contourlevels  function).  source  contours(x,y,z)  Trace 10 automatically chosen contour levels.  source", 
            "title": "Entry points"
        }, 
        {
            "location": "/reference/#accessors", 
            "text": "#  Contour.level     Function .  level(c)  Indicates the  z -value at which the contour level  c  was traced.  source  #  Contour.levels     Function .  Turns the output of  contours  into an iterable with each of the traced contour levels. Each of the objects support  level  and  coordinates .  source  #  Contour.lines     Function .  lines(c)  Extracts an iterable collection of isolines from a contour level. Use  coordinates  to get the coordinates of a line.  source  #  Contour.coordinates     Function .  coordinates(c)  Returns the coordinates of the vertices of the contour line as a tuple of lists.  source", 
            "title": "Accessors"
        }, 
        {
            "location": "/reference/#utilities", 
            "text": "#  Contour.contourlevels     Function .  contourlevels(z,n)  Examines the values of  z  and chooses  n  evenly spaced levels to trace.  source", 
            "title": "Utilities"
        }
    ]
}